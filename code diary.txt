okay. decided to start over and make a DbC framework. 
this get much closer to the most important aspect of my idea.
I'm gonna dive into this and see what I can build on 7 litres of coffee.

wrote a crude start on a Contract class. kinda following rdbc. 

next: try with Contracts as Modules.

#make contracts modules... 
#then you can include them... 
#and include multiple sub contracts
#inherit compile time code

hmm. looks like Contracts will have to be a class anyway...

okay, this is coming along.

&&&&&&&&&&&&&&&

it's looking like I'll have to use evals instead of blocks.
	1. be able to change the binding...
	2. check the code for naughtyness (security)
	3. print it out if I want to.


okay, a bit of trouble feeding context through to next post step. 
but I got it working... 
it's complicated by having a decorator which pretends to be the contracted object.

but I got it to work passing a hash through... that gives the procs the weird syntax of refuring to variables like self[:name] = whatever.

instead, i'll use a context class which has @object and @pre_conditions and @post_conditions 

wow! got it working. 
testing and tidying tomorrow 
and add eval to message... that way can customize the message to give good debuging information!

need a way to verify the contract for initialization.

okay, refactored pre and post methods to use the same methods and differ only on symbols.

NEXT: is test framework to process examples for contracts and report on coverage... + and - examples. 
report on which:
	- methods don't have contracts
	- contracts don't have +/- examples.

on the horizon:
	way to process exception contracts.

okay, contracts are coming along. I can think of a few ways to make examples dryer, 
maybe write contract clauses along with examples, in a TDD style.

wrote more of the contract for array, but there is a lot of work there. 
it might be more important to write contracts for contracts, conditions, etc.

and then implement
copule(contract) --> returns a class which abides by contract.
i.e. so you can use
couple(:ArrayContract).new
instead of 
Array.new

todo list:
	better contract testing/examples
	exception contracts
	contracts for initialization.
	 - contracts for class methods. (that covers new)
	state aware contracts. (i.e. set before get)

	way to refur to a type by it's contracts.

	build model of what classes obey which contracts.(integration of contracts with tests)

		-a body of code which makes objects exercise thier contracts and verify whether they observe them,

	what is a class?
		a class is only really a class with meta information for a particular type of objects.
		so the contract for class would be for new to create an instance where x.new.class == x
		also, simulatiries between X.instance_methods and X.new.methods

		classes which create methods via another static method, create, etc.
		options

			couple(contract).init(args) -> directly create a object which follows contract.
			Contract.couple(args) -> "
			couple(contract).new -> couple(contract) returns the class of an object obeying contract. 
			
		have contracts specify a contract for thier class? 

		have methods to specify contracts for class...

	maybe contracts shouldn't be classes at all. they are currently not getting any benefit from being classes.
	i'll have to implement my own inheritence... but classes don't inherit my clauses because they don't make methods.
		


